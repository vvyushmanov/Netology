# Домашнее задание к занятию "6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

### Ответ

1. Список команд остановки запроса:
    * `db.killOp(<opId>)`, где opID - ID запроса (операции).
    * Узнать ID операции можно либо в Grafana (если был настроен мониторинг), либо с помощью mongo-shell запросом `db.currentOp({"secs_running":{"$gte":5}}`)
    * Производить такое прерывание безопасно только на операциях чтения из базы, на операции записи это может привести к повреждению данных
2. Решение проблем с долгими запросами:
    * Не выдавать пользователям прямой доступ к базе
    * Настроить в запросах maxTimeMS, которая будет автоматически прерывать операции, если они выполняются дольше указанного времени.

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

### Ответ

* Когда реплицируется большой объем информации, это может "положить" сеть, в результате чего Редис может, в том числе, блокировать операции записи.
* Согласно гайду по траблшутингу Редиса


```
 "если в базе данных есть много-много ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% текущей совокупности ключей с установленным сроком действия , Redis может заблокировать, чтобы получить процент ключей, срок действия которых уже истек. ниже 25%". 
```

Т.е. такие блокировки предусмотрены на случай чрезмерно высокой нагрузки. 
https://redis.io/docs/management/optimization/latency/#latency-generated-by-expires

 
## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

### Ответ

1. Налицо сетевая проблема, необходимо понять, на чьей стороне (или на каком узле, если сеть сложная) происходит разрыв соединения.
2. Необходимо снять дамп трафика на узлах, искать ошибки наподобие broken pipe, свидетельствующие о закрытии TCP сессии с одной из сторон
3. Одним из возможных вариантов может быть задержка на стороне клиента или сервера дольше таймаута для TCP соединения
4. В зависимости от того, на чьей стороне происходят проблемы, необходимо проанализировать и оптимизировать сетевой стек

## Задача 4


Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

### Ответ

1. Происходит Out-of-memory, т.е. оперативная память заканчивается и исполняется служба убийства процессов (принудительно)
2. Необходимо оптимизировать конфигурацию PostgreSQL таким образом, чтобы имело место ограничение на использование памяти. Можно "потюнить" такие параметры, как shared_buffers, temp_buffers, work_mem и max_connections.
3. Можно использовать, в качестве отправной точки, гайд: https://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server
4. Необходимо настроить мониторинг (postgresql exporter > Prometheus), чтобы была возможность узнать, что конкретно происходит/происходило в момент переполнения памяти
5. При наличии возможности, добавить ресурсов системе (если виртуальная машина, выделить больше памяти, если bare metal - поставить больше оперативной памяти)